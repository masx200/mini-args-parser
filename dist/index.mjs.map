{"version":3,"file":"index.mjs","sources":["../lib/index.js","../lib/parseargs.js","../src/index.ts"],"sourcesContent":["import assert from \"assert\";\r\nimport { parseargs } from \"./parseargs.js\";\r\n/**\r\n * @param {string[]} args\r\n * @returns {Object}\r\n */\r\nexport default function parse(args) {\r\n    assert(Array.isArray(args));\r\n    const result = parseargs(args);\r\n    const others = args.filter((a) => {\r\n        return typeof a === \"string\" && !a.startsWith(\"-\");\r\n    });\r\n    result[Symbol.iterator] = others[Symbol.iterator].bind(others);\r\n    return result;\r\n}\r\n","/**\r\n * @param {string[]} args\r\n * @returns {Object}\r\n */\r\nfunction parseargs(args) {\r\n    const 参数obj = Object.create(null);\r\n    args.filter((s) => s.startsWith(\"--\"))\r\n        .map((s) => /--(?<key>.+?)=(?<value>.+)/g.exec(s))\r\n        .forEach((execArray) => {\r\n            const groups = execArray?.groups;\r\n            const key = groups?.key;\r\n            const value = groups?.value;\r\n            if (key && value) {\r\n                参数obj[key] = value;\r\n            }\r\n        });\r\n    return 参数obj;\r\n}\r\nexport { parseargs };\r\n","import parseArgs from \"../lib/index.js\";\r\n\r\nfunction parse(args: string[]): Record<string, string | boolean> & {\r\n    [Symbol.iterator]: () => IterableIterator<string>;\r\n} {\r\n    const args1: string[] = [];\r\n    const args2: string[] = [];\r\n    const args3: string[] = [];\r\n\r\n    for (const arg of args) {\r\n        if (arg === \"--\") {\r\n            args3.push(...args.slice(args.indexOf(arg) + 1));\r\n            break;\r\n        } else if (arg.startsWith(\"-\") && !arg.includes(\"=\")) {\r\n            args1.push(arg);\r\n        } else {\r\n            args2.push(arg);\r\n        }\r\n    }\r\n    const res: Record<string, string | boolean> & {\r\n        [Symbol.iterator]: () => IterableIterator<string>;\r\n    } = parseArgs(args2);\r\n\r\n    for (const arg of args1) {\r\n        if (arg.startsWith(\"--\") && arg.length > 2 && arg[2] !== \"-\") {\r\n            res[arg.slice(2)] = true;\r\n        } else if (arg.startsWith(\"-\") && arg.length > 1 && arg[1] !== \"-\") {\r\n            for (const c of arg.slice(1)) {\r\n                res[c] = true;\r\n            }\r\n        }\r\n    }\r\n    const array = [...res];\r\n    res[Symbol.iterator] = () => {\r\n        return [...array, ...args3][Symbol.iterator]();\r\n    };\r\n    return res;\r\n}\r\nexport default parse;\r\n"],"names":["parse","args","assert","Array","isArray","result","参数obj","Object","create","filter","s","startsWith","map","_wrapRegExp","exec","forEach","execArray","groups","key","value","parseargs","others","a","Symbol","iterator","bind","args1","args2","args3","arg","push","slice","indexOf","includes","res","parseArgs","length","c","array"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMe,SAASA,EAAMC;IAC1BC,EAAOC,MAAMC,QAAQH;IACrB,IAAMI,ICJV,SAAmBJ;QACf,IAAMK,IAAQC,OAAOC,OAAO;QAW5B,OAVAP,EAAKQ,QAAQC,KAAMA,EAAEC,WAAW,QAC3BC,KAAKF,KAAMG,EAA8BC,uBAAAA;YAAAA,KAAAA;YAAAA,OAAAA;WAAAA,KAAKJ,KAC9CK,SAASC;YACN,IAAMC,IAASD,iBAAAA,IAAAA,EAAWC,QACpBC,IAAMD,iBAAAA,IAAAA,EAAQC,KACdC,IAAQF,iBAAAA,IAAAA,EAAQE;YAClBD,KAAOC,MACPb,EAAMY,KAAOC;AACjB,aAEDb;AACX,KDTmBc,CAAUnB,IACnBoB,IAASpB,EAAKQ,QAAQa,KACJ,mBAANA,MAAmBA,EAAEX,WAAW;IAGlD,OADAN,EAAOkB,OAAOC,YAAYH,EAAOE,OAAOC,UAAUC,KAAKJ,IAChDhB;AACX;;AEZA,SAASL,EAAMC;IAGX,MAAMyB,IAAkB,IAClBC,IAAkB,IAClBC,IAAkB;IAExB,KAAK,MAAMC,KAAO5B,GAAM;QACpB,IAAY,SAAR4B,GAAc;YACdD,EAAME,QAAQ7B,EAAK8B,MAAM9B,EAAK+B,QAAQH,KAAO;YAC7C;;QACOA,EAAIlB,WAAW,SAASkB,EAAII,SAAS,OAC5CP,EAAMI,KAAKD,KAEXF,EAAMG,KAAKD;AAEnB;IACA,MAAMK,IAEFC,EAAUR;IAEd,KAAK,MAAME,KAAOH,GACd,IAAIG,EAAIlB,WAAW,SAASkB,EAAIO,SAAS,KAAgB,QAAXP,EAAI,IAC9CK,EAAIL,EAAIE,MAAM,OAAM,QACjB,IAAIF,EAAIlB,WAAW,QAAQkB,EAAIO,SAAS,KAAgB,QAAXP,EAAI,IACpD,KAAK,MAAMQ,KAAKR,EAAIE,MAAM,IACtBG,EAAIG,MAAK;IAIrB,MAAMC,IAAQ,KAAIJ;IAIlB,OAHAA,EAAIX,OAAOC,YAAY,MACZ,KAAIc,MAAUV,IAAOL,OAAOC,aAEhCU;AACX;;"}